// Generated by CoffeeScript 1.6.3
(function() {
  var $, Board, Tile, build_map, fisherYates, lay_random_tiles;

  $ = jQuery;

  lay_random_tiles = function(colors, tiles, board, interval) {
    var color, i, insert_tile, last_was_placeable, num, rotate_tile, rotations_for_tile, stack, tile_stack, timer, type, unplaceable, _i, _j, _len, _ref;
    console.log('laying tiles');
    this.stop = false;
    this.running = true;
    tile_stack = [];
    unplaceable = [];
    last_was_placeable = true;
    _ref = colors.reverse();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      color = _ref[_i];
      stack = [];
      for (type in tiles) {
        num = tiles[type];
        for (i = _j = 1; _j <= num; i = _j += 1) {
          stack.push([color, type]);
        }
      }
      fisherYates(stack);
      tile_stack = tile_stack.concat(stack);
    }
    rotations_for_tile = function(t) {
      var rotations;
      rotations = {
        '1': 4,
        '2-straight': 2,
        '2-turn': 4,
        '3': 4,
        '4': 1
      };
      return rotations[t];
    };
    rotate_tile = function(t, color, orientation) {
      var east, name, north, south, west;
      switch (t) {
        case '1':
          east = orientation === 3;
          west = orientation === 1;
          north = orientation === 2;
          south = orientation === 4;
          break;
        case '2-straight':
          east = orientation === 1;
          west = orientation === 1;
          north = orientation === 2;
          south = orientation === 2;
          break;
        case '2-turn':
          east = orientation === 1 || orientation === 4;
          west = orientation === 2 || orientation === 3;
          north = orientation === 3 || orientation === 4;
          south = orientation === 1 || orientation === 2;
          break;
        case '3':
          east = orientation === 1 || orientation === 2 || orientation === 3;
          west = orientation === 1 || orientation === 3 || orientation === 4;
          north = orientation === 1 || orientation === 2 || orientation === 4;
          south = orientation === 2 || orientation === 3 || orientation === 4;
          break;
        case '4':
          east = true;
          west = true;
          north = true;
          south = true;
      }
      name = "" + color + t + "-" + orientation + ".png";
      return [north, east, south, west, name];
    };
    insert_tile = function(color, t) {
      var east, east_tile, fits, max, name, north, north_tile, orientation, orientations, slot, slots, south, south_tile, tile, west, west_tile, x, y, _k, _l, _len1, _len2, _m, _ref1, _results;
      slots = board.find_valid_openings();
      fisherYates(slots);
      i = 0;
      for (_k = 0, _len1 = slots.length; _k < _len1; _k++) {
        slot = slots[_k];
        max = rotations_for_tile(t);
        orientations = (function() {
          _results = [];
          for (var _l = 1; 1 <= max ? _l <= max : _l >= max; 1 <= max ? _l++ : _l--){ _results.push(_l); }
          return _results;
        }).apply(this);
        fisherYates(orientations);
        for (_m = 0, _len2 = orientations.length; _m < _len2; _m++) {
          orientation = orientations[_m];
          i++;
          x = slot[0];
          y = slot[1];
          _ref1 = rotate_tile(t, color, orientation), north = _ref1[0], east = _ref1[1], south = _ref1[2], west = _ref1[3], name = _ref1[4];
          north_tile = board.tile_at(x, y + 1);
          east_tile = board.tile_at(x + 1, y);
          south_tile = board.tile_at(x, y - 1);
          west_tile = board.tile_at(x - 1, y);
          fits = true;
          if (north_tile && (north_tile.south !== north)) {
            fits = false;
          }
          if (east_tile && (east_tile.west !== east)) {
            fits = false;
          }
          if (south_tile && (south_tile.north !== south)) {
            fits = false;
          }
          if (west_tile && (west_tile.east !== west)) {
            fits = false;
          }
          if (fits) {
            tile = new Tile("images/" + name, x, y, north, east, south, west, board.size);
            board.add_tile(tile);
            last_was_placeable = true;
            return true;
          }
        }
      }
      unplaceable.push([color, t]);
      last_was_placeable = false;
      return false;
    };
    return timer = setInterval((function() {
      var next_tile;
      if (this.stop) {
        console.log('Stopping as requested');
        clearInterval(timer);
        this.running = false;
        return false;
      }
      if (tile_stack.length === 0 && (!last_was_placeable || unplaceable.length === 0)) {
        console.log('Placed the last tile');
        console.log(tile_stack);
        console.log(unplaceable);
        console.log("Placed " + board.count + " tiles");
        clearInterval(timer);
        this.running = false;
        console.log('after');
      }
      if (unplaceable.length > 0 && last_was_placeable) {
        next_tile = unplaceable.pop();
      } else {
        next_tile = tile_stack.pop();
      }
      return insert_tile.apply(this, next_tile);
    }), interval);
  };

  fisherYates = function(arr) {
    var i, j, _ref, _results;
    i = arr.length;
    if (i === 0) {
      return false;
    }
    _results = [];
    while (--i) {
      j = Math.floor(Math.random() * (i + 1));
      _results.push((_ref = [arr[j], arr[i]], arr[i] = _ref[0], arr[j] = _ref[1], _ref));
    }
    return _results;
  };

  Tile = (function() {
    function Tile(image, x, y, north, east, south, west, size) {
      this.image = image;
      this.x = x;
      this.y = y;
      this.north = north;
      this.east = east;
      this.south = south;
      this.west = west;
      this.size = size;
      if (this.size === 121) {
        this.offset = 8;
      } else {
        this.offset = 16;
      }
    }

    Tile.prototype.draw = function(context) {
      var _this = this;
      this.img = new Image;
      this.img.setAtX = this.x + this.offset;
      this.img.setAtY = -1 * this.y + this.offset;
      this.img.onload = function() {
        return context.drawImage(_this.img, _this.img.setAtX * _this.size, _this.img.setAtY * _this.size, _this.size, _this.size);
      };
      this.img.src = this.image;
      return this;
    };

    return Tile;

  })();

  Board = (function() {
    function Board(context, size) {
      this.context = context;
      this.size = size;
      this.tiles = {};
      this.count = 0;
      if (this.size === 60) {
        this.x = 16;
        this.y = 16;
      } else {
        this.x = 8;
        this.y = 8;
      }
    }

    Board.prototype.add_start_tile = function() {
      var start_tile;
      start_tile = new Tile('images/start.png', 0, 0, true, true, true, true, this.size);
      return this.add_tile(start_tile);
    };

    Board.prototype.add_tile = function(tile) {
      var obj;
      if (this.tile_at(tile.x, tile.y)) {
        return false;
      }
      if (this.tiles[tile.x]) {
        obj = this.tiles[tile.x];
        obj[tile.y] = tile;
      } else {
        obj = {};
        obj[tile.y] = tile;
        this.tiles[tile.x] = obj;
      }
      this.count += 1;
      return tile.draw(this.context);
    };

    Board.prototype.wall_at = function(x, y) {
      return Math.abs(x) > this.x || Math.abs(y) > this.y;
    };

    Board.prototype.tile_at = function(x, y) {
      var exists, ys;
      exists = false;
      ys = this.tiles[x];
      if (ys) {
        exists = ys[y];
      }
      return exists;
    };

    Board.prototype.tile_count = function() {
      return this.count;
    };

    Board.prototype.find_valid_openings = function() {
      var coords, openings, tile, tiles, x, y, _ref;
      openings = [];
      _ref = this.tiles;
      for (x in _ref) {
        tiles = _ref[x];
        for (y in tiles) {
          tile = tiles[y];
          if (tile.north) {
            coords = [tile.x, tile.y + 1];
            if (!(this.tile_at.apply(this, coords) || this.wall_at.apply(this, coords))) {
              openings.push(coords);
            }
          }
          if (tile.east) {
            coords = [tile.x + 1, tile.y];
            if (!(this.tile_at.apply(this, coords) || this.wall_at.apply(this, coords))) {
              openings.push(coords);
            }
          }
          if (tile.south) {
            coords = [tile.x, tile.y - 1];
            if (!(this.tile_at.apply(this, coords) || this.wall_at.apply(this, coords))) {
              openings.push(coords);
            }
          }
          if (tile.west) {
            coords = [tile.x - 1, tile.y];
            if (!(this.tile_at.apply(this, coords) || this.wall_at.apply(this, coords))) {
              openings.push(coords);
            }
          }
        }
      }
      return openings;
    };

    return Board;

  })();

  $(document).ready(function() {
    $('.save').click(function() {
      var canvas, image;
      canvas = document.getElementById('my_canvas');
      image = canvas.toDataURL('map.png').replace('image/png', 'image/octet-stream');
      if (!this.lnk) {
        this.lnk = document.createElement('a');
      }
      this.lnk.download = 'map.png';
      this.lnk.href = image;
      return this.lnk.click();
    });
    return $('.submit').click(function() {
      var interval, size, tiles;
      size = parseInt($('.size').val());
      interval = parseInt($('.interval').val());
      tiles = {
        '4': parseInt($('.4').val()) || 0,
        '3': parseInt($('.3').val()) || 0,
        '2-straight': parseInt($('.2-straight').val()) || 0,
        '2-turn': parseInt($('.2-turn').val()) || 0,
        '1': parseInt($('.1').val()) || 0
      };
      return build_map(tiles, size, interval);
    });
  });

  build_map = function(tiles, size, interval) {
    var canvas, context, stopping;
    canvas = document.getElementById('my_canvas');
    context = canvas.getContext('2d');
    this.stop = true;
    return stopping = setInterval((function() {
      var board, colors;
      if (this.running) {
        return console.log('waiting for the previous draw to stop');
      } else {
        console.log('starting to draw');
        context.clearRect(0, 0, 2057, 2057);
        colors = ['green', 'yellow', 'red'];
        board = new Board(context, size);
        board.add_start_tile();
        lay_random_tiles(colors, tiles, board, interval);
        return clearInterval(stopping);
      }
    }), 10);
  };

}).call(this);
